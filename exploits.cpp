#include "includes.h"

Exploits		g_exploits{};;

void Exploits::Team() {
	if( !g_menu.main.misc.spawn_exploit.get( ) )
		return;

	// get our teams for the exploit.
	int team = g_cl.m_local->m_iTeamNum();

	// spawn exploit.
	if ( g_cl.m_local->alive() && !g_cl.m_local->m_bControlledBot() && (team == TEAM_COUNTERTERRORISTS || team == TEAM_TERRORISTS) ) {
		int health = g_cl.m_local->m_iHealth();

		if ( health > g_menu.main.misc.spawn_exploit_health.get() ) {
			g_notify.add(XOR("executing exploit\n"));

			// execute this command which sets our team to unassigned and our iTeamNum to zero.
			g_csgo.m_engine->ExecuteClientCmd(XOR("resetteam"));

			// rejoin our team, otherwise we are unassigned.
			g_csgo.m_engine->ExecuteClientCmd(tfm::format(XOR("jointeam %s 1"), team).data());
		}
	}
}

void Exploits::Command() {
	int active = g_menu.main.misc.active_exploit.get( );

	if( active == 0 || m_last_command >= g_csgo.m_globals->m_curtime )
		return;

	// team exploit.
	if ( active == 1 ) {
		int team = g_csgo.RandomInt(1, 3);

		// execute our spammer. the second argument forces the server to listen even if we are spamming it.
		g_csgo.m_engine->ExecuteClientCmd(tfm::format(XOR("jointeam %s 1"), team).data());

		// waiting this long might be overkill but the server only allows 40 messages by default (sv_quota_stringcmdspersecond).
		m_last_command = g_csgo.m_globals->m_curtime + CS_COMMAND_MAX_RATE;
	}

	// deathmatch godmode.
	else { 	
		// run our exploit command.
		g_csgo.m_engine->ExecuteClientCmd(XOR("open_buymenu"));

		// we can add some extra time to this because it already adds 10 to our time anyway. 
		m_last_command = g_csgo.m_globals->m_curtime + CS_COMMAND_MAX_RATE + 5;
	}
}
